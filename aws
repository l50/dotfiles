# Authorize Security Group Ingress
#
# Authorizes inbound traffic for the specified security group if the rule doesn't already exist.
# Creates the security group if it doesn't already exist.
#
# Usage:
#   authorize_security_group_ingress [group_name] [group_description] [vpc_id] [protocol] [port] [cidr]
#
# Output:
#   Returns the id of the security group, but configures the security group to allow inbound traffic if the rule is added.
#   If the security group or rule already exists, outputs a message indicating the existing group or rule.
#
# Example(s):
#   SECURITY_GROUP_ID=$(authorize_security_group_ingress "my_security_group" "Description of my security group" "vpc-0abcd1234efgh5678" "tcp" "22" "0.0.0.0/0")
function authorize_security_group_ingress() {
    local group_name=$1
    local group_description=$2
    local vpc_id=$3
    local protocol=$4
    local port=$5
    local cidr=$6

    # Check if the security group already exists
    local security_group_id
    security_group_id=$(aws ec2 describe-security-groups --filters Name=group-name,Values="$group_name" --query 'SecurityGroups[0].GroupId' --output text)

    # If the security group doesn't exist or command fails, create it
    if [ -z "$security_group_id" ] || [ "$security_group_id" == "None" ]; then
        if ! security_group_id=$(aws ec2 create-security-group --group-name "$group_name" --description "$group_description" --vpc-id "$vpc_id" --query 'GroupId' --output text); then
            echo "Failed to create security group: $group_name"
            return 1
        fi
        echo "Created security group $group_name with ID: $security_group_id"
    else
        echo "Security group $group_name already exists with ID: $security_group_id"
    fi

    # Check if the ingress rule already exists
    local existing_rule
    existing_rule=$(aws ec2 describe-security-groups \
        --group-ids "$security_group_id" \
        --query "SecurityGroups[0].IpPermissions[?IpProtocol=='$protocol' && FromPort=='$port' && contains(IpRanges[].CidrIp, '$cidr')]")

    if [ -n "$existing_rule" ]; then
        echo "Ingress rule already exists for: $protocol port $port from $cidr"
        echo "$security_group_id"
    else
        if aws ec2 authorize-security-group-ingress \
            --group-id "$security_group_id" \
            --protocol "$protocol" \
            --port "$port" \
            --cidr "$cidr"; then
            echo "Added ingress rule to security group $group_name"
            echo "$security_group_id"
        else
            echo "Failed to add ingress rule to security group $group_name"
            return 1
        fi
    fi
}

# Create EC2 Instance
#
# Creates an EC2 instance with the specified AMI, instance type, and security group.
#
# Usage:
#   create_ec2_instance
#
# Output:
#   Outputs the ID of the created EC2 instance.
#
# Example(s):
#   create_ec2_instance
create_ec2_instance() {
    AMI_ID="$1"
    INSTANCE_TYPE="${2:-t3.micro}"
    IAM_INSTANCE_PROFILE="${3:-AmazonSSMInstanceProfileForInstances}"
    INSTANCE_NAME="${4:-My-EC2-Instance}"
    SECURITY_GROUP_NAME="${5:-default-sg}"
    SECURITY_GROUP_DESC="${6:-Default Security Group}"
    VPC_ID="$7"
    DEFAULT_SUBNET_ID="$8"

    SECURITY_GROUP_ID=$(authorize_security_group_ingress "$SECURITY_GROUP_NAME" "$SECURITY_GROUP_DESC" "${VPC_ID}" "tcp" 22 "0.0.0.0/0" | tail -n 1)

    INSTANCE_ID=$(aws ec2 run-instances \
        --image-id "$AMI_ID" \
        --count 1 \
        --instance-type "$INSTANCE_TYPE" \
        --security-group-ids "$SECURITY_GROUP_ID" \
        --subnet-id "$DEFAULT_SUBNET_ID" \
        --iam-instance-profile "Name=$IAM_INSTANCE_PROFILE" \
        --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$INSTANCE_NAME}]" \
        --query 'Instances[0].InstanceId' \
        --output text)

    wait_for_initialization

    if [ -z "$INSTANCE_ID" ]; then
        echo "Failed to create EC2 instance"
        exit 1
    fi
    echo "Created EC2 instance: $INSTANCE_ID" >&2
    echo "${INSTANCE_ID}"
}

# Delete Security Group
#
# Deletes a specified security group.
#
# Usage:
#   delete_security_group "security-group-name"
#
# Output:
#   Deletes the specified security group if it exists. If it doesn't exist,
#   the function outputs a message indicating so.
#   If the function fails to delete the security group, it retries every
#   5 seconds until successful.
#
# Example(s):
#   delete_security_group "my-security-group"
delete_security_group(){
    SEC_GRP="$1"
    # Attempt to get the ID of the security group and capture any error message
    if SEC_GRP_ID=$(aws ec2 describe-security-groups --group-names "$SEC_GRP" --query 'SecurityGroups[0].GroupId' --output text 2> /dev/null); then
        while true; do
            # Try to delete the security group
            if aws ec2 delete-security-group --group-id="$SEC_GRP_ID" > /dev/null 2>&1; then
                # If successful, exit the loop
                echo "Successfully deleted security group: $SEC_GRP"
                break
            else
                # If unsuccessful, sleep for 5 seconds and try again
                echo "Failed to delete security group: $SEC_GRP. Retrying in 5 seconds..."
                sleep 5
            fi
        done
    else
        echo "Security group $SEC_GRP does not exist, nothing to delete."
    fi
}

# Download Bucket
#
# Syncs the contents of the specified Amazon S3 bucket to the
# specified local destination directory or to the current directory
# if no destination is provided.
#
# Usage:
#   download_bucket [bucket-name] [destination-directory]
#
# Output:
#   Syncs the files from the S3 bucket to the local destination.
#
# Example(s):
#   download_bucket "mybucket" "$HOME"
#   download_bucket "mybucket"
download_bucket() {
	bucket="${1}"
	if [[ -z "${bucket}" ]]; then
		echo "You need to supply a bucket!"
		echo "Example: download_bucket mybucket $HOME"
		return 1
	fi
	dest="${2}"
	if [[ -z "${dest}" ]]; then
		dest='.'
	fi

	aws s3 sync "s3://${1}" "${dest}"
}

# Find Default Subnet
#
# Finds the default subnet ID.
#
# Usage:
#   find_default_subnet
#
# Output:
#   Outputs the default subnet ID.
#
# Example(s):
#   find_default_subnet
function find_default_subnet() {
    aws ec2 describe-subnets \
        --filters "Name=default-for-az,Values=true" \
        --output text --query 'Subnets[0].SubnetId'
}

# Find Default VPC
#
# Finds the default VPC ID.
#
# Usage:
#   find_default_vpc
#
# Output:
#   Outputs the default VPC ID.
#
# Example(s):
#   find_default_vpc
function find_default_vpc() {
    aws ec2 describe-vpcs \
        --filters "Name=isDefault,Values=true" \
        --output text --query 'Vpcs[0].VpcId'
}

# Get Instances by Specified Attribute
#
# Fetches the ID of the EC2 instances based on Name, ARN, or Tag Name.
#
# Usage:
#   find_instance "attribute-type" "attribute-value"
#   where attribute-type can be "name", "arn", or "tag"
#
# Output:
#   Outputs the ID of the EC2 instances based on the specified attribute type and value.
#
# Example(s):
#   INSTANCES=$(find_instance "tag" "prod")
#   INSTANCES=$(find_instance "name" "my-instance")
#   INSTANCES=$(find_instance "arn" "arn:aws:ec2:region:account-ID-without-hyphens:instance/instance-id")
find_instance() {
  ATTRIBUTE_TYPE="$1"
  ATTRIBUTE_VALUE="$2"

  JSON=$(aws ec2 describe-instances --output json)

  case $ATTRIBUTE_TYPE in
    "arn")
      echo "$JSON" | jq -r --arg arn "$ATTRIBUTE_VALUE" '.Reservations[].Instances[] | select(.InstanceArn == $arn) | select(.State.Name == "running") | .InstanceId'
      ;;
    "name")
      echo "$JSON" | jq -r --arg name "$ATTRIBUTE_VALUE" '.Reservations[].Instances[] | select(.Tags[]? | (.Key == "Name" and .Value == $name)) | select(.State.Name == "running") | .InstanceId'
      ;;
    "tag")
      echo "$JSON" | jq -r --arg tag "$ATTRIBUTE_VALUE" '.Reservations[].Instances[] | select(.Tags[]? | .Value == $tag) | select(.State.Name == "running") | .InstanceId'
      ;;
    *)
      echo "Invalid attribute type. Use arn, name, or tag."
      return 1
      ;;
  esac
}

# Get Instance Role Credentials
#
# Retrieves the IAM role credentials from the specified EC2 instance.
#
# Usage:
#   get_instance_role_credentials "instance-id"
#   where "instance-id" is the ID of the EC2 instance from which you want to retrieve the IAM role credentials.
#
# Output:
#   Outputs the IAM role credentials.
#
# Example(s):
#   CREDENTIALS=$(get_instance_role_credentials "i-0c4d3a12d5efc5d4d")
get_instance_role_credentials() {
    local INSTANCE_ID=$1
    ROLE_NAME_COMMAND='curl http://169.254.169.254/latest/meta-data/iam/security-credentials/'
    COMMAND_ID=$(aws ssm send-command --instance-ids "$INSTANCE_ID" --document-name AWS-RunShellScript --parameters "commands=[\"$ROLE_NAME_COMMAND\"]" --query "Command.CommandId" --output text)
    wait_for_command "$COMMAND_ID"
    ROLE_NAME=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text)

    GET_CREDENTIALS_COMMAND="curl http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME"
    COMMAND_ID=$(aws ssm send-command --instance-ids "$INSTANCE_ID" --document-name AWS-RunShellScript --parameters "commands=[\"$GET_CREDENTIALS_COMMAND\"]" --query "Command.CommandId" --output text)
    wait_for_command "$COMMAND_ID"
    CREDENTIALS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text)
    echo "$CREDENTIALS"
}

# Get Latest AMI
#
# Fetches the ID of the latest Amazon Machine Image (AMI) for the
# specified OS distribution, version, and architecture.
#
# Usage:
#   get_latest_ami [distro] [version] [architecture]
#
# Output:
#   Outputs the ID of the AMI.
#
# Example(s):
#   get_latest_ami "ubuntu" "20.04" "amd64"
# Get Latest AMI
# Fetches the ID of the latest Amazon Machine Image (AMI) for the
# specified OS distribution, version, and architecture.
#
# Usage:
#   get_latest_ami [distro] [version] [architecture]
#
# Output:
#   Outputs the ID of the AMI.
#
# Example(s):
#   get_latest_ami "ubuntu" "20.04" "amd64"
function get_latest_ami() {
    local distro=$1
    local version=$2
    local architecture=$3

    if [[ "$distro" == "ubuntu" ]]; then
        if [[ "$version" == "22.04" ]]; then
            if [[ "$architecture" == "amd64" ]]; then
                amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-jammy-%s-amd64-server-*"
            elif [[ "$architecture" == "arm64" ]]; then
                amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-jammy-%s-arm64-server-*"
            else
                echo "Unsupported architecture: $architecture"
                return 1
            fi
        elif [[ "$version" == "20.04" ]]; then
            if [[ "$architecture" == "amd64" ]]; then
                amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-focal-%s-amd64-server-*"
            elif [[ "$architecture" == "arm64" ]]; then
                amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-focal-%s-arm64-server-*"
            else
                echo "Unsupported architecture: $architecture"
                return 1
            fi
        elif [[ "$version" == "18.04" ]]; then
            if [[ "$architecture" == "amd64" ]]; then
                amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-bionic-%s-amd64-server-*"
            elif [[ "$architecture" == "arm64" ]]; then
                amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-bionic-%s-arm64-server-*"
            else
                echo "Unsupported architecture: $architecture"
                return 1
            fi
        else
            echo "Unsupported version: $version"
            return 1
        fi
        owner="099720109477"  # Canonical
    elif [[ "$distro" == "centos" ]]; then
        if [[ "$version" == "7" ]]; then
            if [[ "$architecture" == "x86_64" ]]; then
                amiNamePattern="CentOS Linux %s x86_64 HVM EBS*"
            elif [[ "$architecture" == "arm64" ]]; then
                amiNamePattern="CentOS Linux %s arm64 HVM EBS*"
            else
                echo "Unsupported architecture: $architecture"
                return 1
            fi
        elif [[ "$version" == "8" ]]; then
            if [[ "$architecture" == "x86_64" ]]; then
                amiNamePattern="CentOS %s AMI*"
            elif [[ "$architecture" == "arm64" ]]; then
                amiNamePattern="CentOS %s ARM64 AMI*"
            else
                echo "Unsupported architecture: $architecture"
                return 1
            fi
        else
            echo "Unsupported version: $version"
            return 1
        fi
        owner="679593333241"  # Kali Linux
    elif [[ "$distro" == "debian" ]]; then
        if [[ "$version" == "10" ]]; then
            if [[ "$architecture" == "amd64" ]]; then
                amiNamePattern="debian-%s-buster-hvm-amd64-gp2*"
            elif [[ "$architecture" == "arm64" ]]; then
                amiNamePattern="debian-%s-buster-hvm-arm64-gp2*"
            else
                echo "Unsupported architecture: $architecture"
                return 1
            fi
        else
            echo "Unsupported version: $version"
            return 1
        fi
        owner="136693071363"  # Debian
    elif [[ "$distro" == "kali" ]]; then
        if [[ "$version" == "2023.1" ]]; then
            if [[ "$architecture" == "amd64" ]]; then
                amiNamePattern="kali-linux-%s-amd64*"
            elif [[ "$architecture" == "arm64" ]]; then
                amiNamePattern="kali-linux-%s-arm64*"
            else
                echo "Unsupported architecture: $architecture"
                return 1
            fi
        else
            echo "Unsupported version: $version"
            return 1
        fi
        owner="679593333241"  # Kali Linux
    else
        echo "Unsupported distribution: $distro"
        return 1
    fi

    # shellcheck disable=SC2059
    amiNamePattern=$(printf "$amiNamePattern" "$version")

    wait

    # Extract the AMI ID using string manipulation
    AMI_ID=$(aws ec2 describe-images \
        --filters "Name=name,Values=$amiNamePattern" \
        --owners "$owner" \
        --query 'sort_by(Images, &CreationDate)[-1].ImageId' \
        --output text)

    if [ -z "$AMI_ID" ]; then
        echo "No images found for distro: $distro, version: $version, architecture: $architecture"
        return 1
    fi

    echo "$AMI_ID"
}

# List Running Instances
#
# Lists all running EC2 instances.
#
# Usage:
#   list_running_instances
#
# Output:
#   Outputs a table of running instances.
#
# Example(s):
#   list_running_instances
list_running_instances() {
  aws ec2 describe-instances \
    --query \
    "Reservations[*].Instances[*].{InstanceId:InstanceId, VPC:VpcId, Subnet:SubnetId, PublicIP:PublicIpAddress,Name:Tags[?Key=='Name']|[0].Value}" \
    --filters Name=instance-state-name,Values=running --output json
}

# List Instance Profiles
#
# Lists all instance profiles.
#
# Usage:
#   list_instance_profiles
#
# Output:
#   Outputs a list of instance profiles.
#
# Example(s):
#   list_instance_profiles
list_instance_profiles() {
    INSTANCE_PROFILE_NAMES=$(aws iam list-instance-profiles --query "InstanceProfiles[].InstanceProfileName" --output text | tr '\t' '\n')

    # For each instance profile, print the name
    for INSTANCE_PROFILE_NAME in $INSTANCE_PROFILE_NAMES; do
        echo "$INSTANCE_PROFILE_NAME"
    done
}

# Terminate Instance
#
# Terminates a specified EC2 instance.
#
# Usage:
#   terminate_instance [instance_id]
#
# Output:
#   Terminates the instance if it's running. If it's already being terminated, the function skips it.
#   If the instance is in an unexpected state, it throws an error.
#
# Example(s):
#   terminate_instance "i-0abcd1234efgh5678"
terminate_instance () {
	local instance_id=$1
	while true
	do
		instance_status=$(aws ec2 describe-instances --instance-ids "$instance_id" --output json | jq -r '.Reservations[0].Instances[0].State.Name')
		if [ "$instance_status" = "terminated" ] || [ "$instance_status" = "shutting-down" ]
		then
			echo "Skipping instance $instance_id which is already $instance_status"
			break
		elif [ "$instance_status" = "running" ]
		then
			echo "Terminating instance: $instance_id"
			aws ec2 terminate-instances --instance-ids "$instance_id"
			break
		else
			echo "Unexpected instance status: $instance_status"
			exit 1
		fi
	done
}

# Wait for Command
#
# Waits for a previously run command to complete.
#
# Usage:
#   wait_for_command [command_id]
#
# Output:
#   No output, but pauses script execution until the specified command has finished running.
#
# Example(s):
#   wait_for_command "0abcd1234efgh5678"
wait_for_command() {
    local command_id=$1
    local command_status

    while true; do
        command_status=$(aws ssm list-command-invocations --command-id "$command_id" --details --query 'CommandInvocations[0].Status' --output text)

        if [ -z "$command_status" ]; then
            echo "Failed to fetch command status."
            exit 1
        elif [ "$command_status" = "Success" ]; then
            break
        elif [ "$command_status" = "Failed" ]; then
            echo "Command execution failed."
            exit 1
        fi

        echo "Waiting for command to finish..."
        sleep 5
    done
}

# Wait for Initialization
#
# Waits until the newly created EC2 instance changes its status
# from "initializing" to another state, signaling that initialization
# has completed.
#
# Usage:
#   wait_for_initialization
#
# Output:
#   No output, but pauses script execution until the EC2 instance has finished initializing.
#
# Example(s):
#   wait_for_initialization
wait_for_initialization() {
    instance_status="initializing"
    while [[ "$instance_status" == "initializing" || "$instance_status" == "null" ]]; do
        instance_status=$(aws ec2 describe-instance-status --instance-id "${INSTANCE_ID}" \
            | jq -r ".InstanceStatuses[0].InstanceStatus.Status")
        sleep 10
    done
}

# List VPCs
#
# Lists all VPCs with their ID, Name (if tagged), and State.
#
# Usage:
#   list_vpcs
#
# Output:
#   Outputs a table of VPCs with their ID, Name, and State.
#
# Example(s):
#   list_vpcs
list_vpcs() {
    echo "Listing VPCs..."
    aws ec2 describe-vpcs --query 'Vpcs[].{ID:VpcId, Name:Tags[?Key==`Name`]|[0].Value, State:State}' --output table
}
