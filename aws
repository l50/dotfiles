# Authorize Security Group Ingress
#
# Authorizes inbound traffic for the specified security group if the rule doesn't already exist.
# Creates the security group if it doesn't already exist.
#
# Usage:
#   authorize_security_group_ingress [group_name] [group_description] [vpc_id] [protocol] [port] [cidr]
#
# Output:
#   Returns the id of the security group, but configures the security group to allow inbound traffic if the rule is added.
#   If the security group or rule already exists, outputs a message indicating the existing group or rule.
#
# Example(s):
#   SECURITY_GROUP_ID=$(authorize_security_group_ingress "my_security_group" "Description of my security group" "vpc-0abcd1234efgh5678" "tcp" "22" "0.0.0.0/0")
function authorize_security_group_ingress() {
    local group_name=$1
    local group_description=$2
    local vpc_id=$3
    local protocol=$4
    local port=$5
    local cidr=$6

    # Check if the security group already exists
    local security_group_id
    security_group_id=$(aws ec2 describe-security-groups --filters Name=group-name,Values="$group_name" --query 'SecurityGroups[0].GroupId' --output text)

    # If the security group doesn't exist or command fails, create it
    if [ -z "$security_group_id" ] || [ "$security_group_id" == "None" ]; then
        if ! security_group_id=$(aws ec2 create-security-group --group-name "$group_name" --description "$group_description" --vpc-id "$vpc_id" --query 'GroupId' --output text); then
            echo "Failed to create security group: $group_name"
            return 1
        fi
        echo "Created security group $group_name with ID: $security_group_id"
    else
        echo "Security group $group_name already exists with ID: $security_group_id"
    fi

    # Check if the ingress rule already exists
    local existing_rule
    existing_rule=$(aws ec2 describe-security-groups \
        --group-ids "$security_group_id" \
        --query "SecurityGroups[0].IpPermissions[?IpProtocol=='$protocol' && FromPort=='$port' && contains(IpRanges[].CidrIp, '$cidr')]")

    if [ -n "$existing_rule" ]; then
        echo "Ingress rule already exists for: $protocol port $port from $cidr"
        echo "$security_group_id"
    else
        if aws ec2 authorize-security-group-ingress \
            --group-id "$security_group_id" \
            --protocol "$protocol" \
            --port "$port" \
            --cidr "$cidr"; then
            echo "Added ingress rule to security group $group_name"
            echo "$security_group_id"
        else
            echo "Failed to add ingress rule to security group $group_name"
            return 1
        fi
    fi
}

# Create EC2 Instance
#
# Creates an EC2 instance with the specified AMI, instance type, and security group.
#
# Usage:
#   create_ec2_instance
#
# Output:
#   Outputs the ID of the created EC2 instance.
#
# Example(s):
#   create_ec2_instance
create_ec2_instance() {
    AMI_ID="$1"
    INSTANCE_TYPE="${2:-t3.micro}"
    IAM_INSTANCE_PROFILE="${3:-AmazonSSMInstanceProfileForInstances}"
    INSTANCE_NAME="${4:-My-EC2-Instance}"
    SECURITY_GROUP_NAME="${5:-default-sg}"
    SECURITY_GROUP_DESC="${6:-Default Security Group}"
    VPC_ID="$7"
    DEFAULT_SUBNET_ID="$8"

    SECURITY_GROUP_ID=$(authorize_security_group_ingress "$SECURITY_GROUP_NAME" "$SECURITY_GROUP_DESC" "${VPC_ID}" "tcp" 22 "0.0.0.0/0" | tail -n 1)

    INSTANCE_ID=$(aws ec2 run-instances \
        --image-id "$AMI_ID" \
        --count 1 \
        --instance-type "$INSTANCE_TYPE" \
        --security-group-ids "$SECURITY_GROUP_ID" \
        --subnet-id "$DEFAULT_SUBNET_ID" \
        --iam-instance-profile "Name=$IAM_INSTANCE_PROFILE" \
        --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$INSTANCE_NAME}]" \
        --query 'Instances[0].InstanceId' \
        --output text)

    wait_for_initialization

    if [ -z "$INSTANCE_ID" ]; then
        echo "Failed to create EC2 instance"
        exit 1
    fi
    echo "Created EC2 instance: $INSTANCE_ID" >&2
    echo "${INSTANCE_ID}"
}

# Download Bucket
#
# Syncs the contents of the specified Amazon S3 bucket to the
# specified local destination directory or to the current directory
# if no destination is provided.
#
# Usage:
#   download_bucket [bucket-name] [destination-directory]
#
# Output:
#   Syncs the files from the S3 bucket to the local destination.
#
# Example(s):
#   download_bucket "mybucket" "$HOME"
#   download_bucket "mybucket"
download_bucket() {
	bucket="${1}"
	if [[ -z "${bucket}" ]]; then
		echo "You need to supply a bucket!"
		echo "Example: download_bucket mybucket $HOME"
		return 1
	fi
	dest="${2}"
	if [[ -z "${dest}" ]]; then
		dest='.'
	fi

	aws s3 sync "s3://${1}" "${dest}"
}

# Find Default Subnet
#
# Finds the default subnet ID.
#
# Usage:
#   find_default_subnet
#
# Output:
#   Outputs the default subnet ID.
#
# Example(s):
#   find_default_subnet
function find_default_subnet() {
    aws ec2 describe-subnets \
        --filters "Name=default-for-az,Values=true" \
        --output text --query 'Subnets[0].SubnetId'
}

# Find Default VPC
#
# Finds the default VPC ID.
#
# Usage:
#   find_default_vpc
#
# Output:
#   Outputs the default VPC ID.
#
# Example(s):
#   find_default_vpc
function find_default_vpc() {
    aws ec2 describe-vpcs \
        --filters "Name=isDefault,Values=true" \
        --output text --query 'Vpcs[0].VpcId'
}

# Get Instances by Specified Attribute
#
# Fetches the ID of the EC2 instances based on Name, ARN, or Tag Name.
#
# Usage:
#   find_instance "attribute-type" "attribute-value"
#   where attribute-type can be "name", "arn", or "tag"
#
# Output:
#   Outputs the ID of the EC2 instances based on the specified attribute type and value.
#
# Example(s):
#   INSTANCES=$(find_instance "tag" "prod")
#   INSTANCES=$(find_instance "name" "my-instance")
#   INSTANCES=$(find_instance "arn" "arn:aws:ec2:region:account-ID-without-hyphens:instance/instance-id")
find_instance() {
  ATTRIBUTE_TYPE="$1"
  ATTRIBUTE_VALUE="$2"

  JSON=$(aws ec2 describe-instances --output json)

  case $ATTRIBUTE_TYPE in
    "arn")
      echo "$JSON" | jq -r --arg arn "$ATTRIBUTE_VALUE" '.Reservations[].Instances[] | select(.InstanceArn == $arn) | select(.State.Name == "running") | .InstanceId'
      ;;
    "name")
      echo "$JSON" | jq -r --arg name "$ATTRIBUTE_VALUE" '.Reservations[].Instances[] | select(.Tags[]? | (.Key == "Name" and .Value == $name)) | select(.State.Name == "running") | .InstanceId'
      ;;
    "tag")
      echo "$JSON" | jq -r --arg tag "$ATTRIBUTE_VALUE" '.Reservations[].Instances[] | select(.Tags[]? | .Value == $tag) | select(.State.Name == "running") | .InstanceId'
      ;;
    *)
      echo "Invalid attribute type. Use arn, name, or tag."
      return 1
      ;;
  esac
}

# Get Instance Role Credentials
#
# Retrieves the IAM role credentials from the specified EC2 instance.
#
# Usage:
#   get_instance_role_credentials "instance-id"
#   where "instance-id" is the ID of the EC2 instance from which you want to retrieve the IAM role credentials.
#
# Output:
#   Outputs the IAM role credentials.
#
# Example(s):
#   CREDENTIALS=$(get_instance_role_credentials "i-0c4d3a12d5efc5d4d")
get_instance_role_credentials() {
    local INSTANCE_ID=$1
    ROLE_NAME_COMMAND='curl http://169.254.169.254/latest/meta-data/iam/security-credentials/'
    COMMAND_ID=$(aws ssm send-command --instance-ids "$INSTANCE_ID" --document-name AWS-RunShellScript --parameters "commands=[\"$ROLE_NAME_COMMAND\"]" --query "Command.CommandId" --output text)
    wait_for_command "$COMMAND_ID"
    ROLE_NAME=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text)

    GET_CREDENTIALS_COMMAND="curl http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME"
    COMMAND_ID=$(aws ssm send-command --instance-ids "$INSTANCE_ID" --document-name AWS-RunShellScript --parameters "commands=[\"$GET_CREDENTIALS_COMMAND\"]" --query "Command.CommandId" --output text)
    wait_for_command "$COMMAND_ID"
    CREDENTIALS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text)
    echo "$CREDENTIALS"
}

# Get Latest AMI
# Fetches the ID of the latest Amazon Machine Image (AMI) for the
# specified OS distribution, version, and architecture.
#
# Usage:
#   get_latest_ami [distro] [version] [architecture]
#
# Output:
#   Outputs the ID of the AMI.
#
# Example(s):
#   get_latest_ami "ubuntu" "22.04" "amd64"
get_latest_ami () {
	local distro=$1
	local version=$2
	local architecture=$3

	# Validate inputs
	if [[ -z "$distro" || -z "$version" || -z "$architecture" ]]; then
		echo "Usage: get_latest_ami <distro> <version> <architecture>"
		echo "Example: get_latest_ami debian 12 amd64"
		return 1
	fi

	case "$distro" in
		"ubuntu")
			case "$version" in
				"22.04")
					case "$architecture" in
						"amd64")
							amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"
							;;
						"arm64")
							amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-arm64-server-*"
							;;
						*)
							echo "Unsupported architecture: $architecture for Ubuntu"
							return 1
							;;
					esac
					;;
				"20.04")
					case "$architecture" in
						"amd64")
							amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"
							;;
						"arm64")
							amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-focal-20.04-arm64-server-*"
							;;
						*)
							echo "Unsupported architecture: $architecture for Ubuntu"
							return 1
							;;
					esac
					;;
				"18.04")
					case "$architecture" in
						"amd64")
							amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-bionic-18.04-amd64-server-*"
							;;
						"arm64")
							amiNamePattern="ubuntu/images/hvm-ssd/ubuntu-bionic-18.04-arm64-server-*"
							;;
						*)
							echo "Unsupported architecture: $architecture for Ubuntu"
							return 1
							;;
					esac
					;;
				*)
					echo "Unsupported version: $version for Ubuntu"
					return 1
					;;
			esac
			owner="099720109477"
			;;
		"centos")
			case "$version" in
				"7")
					case "$architecture" in
						"x86_64")
							amiNamePattern="CentOS Linux 7 x86_64 HVM EBS*"
							;;
						"arm64")
							amiNamePattern="CentOS Linux 7 arm64 HVM EBS*"
							;;
						*)
							echo "Unsupported architecture: $architecture for CentOS"
							return 1
							;;
					esac
					;;
				"8")
					case "$architecture" in
						"x86_64")
							amiNamePattern="CentOS 8 x86_64 AMI*"
							;;
						"arm64")
							amiNamePattern="CentOS 8 arm64 AMI*"
							;;
						*)
							echo "Unsupported architecture: $architecture for CentOS"
							return 1
							;;
					esac
					;;
				*)
					echo "Unsupported version: $version for CentOS"
					return 1
					;;
			esac
			owner="679593333241"
			;;
		"debian")
			case "$version" in
				"10")
					case "$architecture" in
						"amd64")
							amiNamePattern="debian-10-amd64-*"
							;;
						"arm64")
							amiNamePattern="debian-10-arm64-*"
							;;
						*)
							echo "Unsupported architecture: $architecture for Debian"
							return 1
							;;
					esac
					;;
				"11")
					case "$architecture" in
						"amd64")
							amiNamePattern="debian-11-amd64-*"
							;;
						"arm64")
							amiNamePattern="debian-11-arm64-*"
							;;
						*)
							echo "Unsupported architecture: $architecture for Debian"
							return 1
							;;
					esac
					;;
				"12")
					case "$architecture" in
						"amd64")
							amiNamePattern="debian-12-amd64-*"
							;;
						"arm64")
							amiNamePattern="debian-12-arm64-*"
							;;
						*)
							echo "Unsupported architecture: $architecture for Debian"
							return 1
							;;
					esac
					;;
				*)
					echo "Unsupported version: $version for Debian"
					return 1
					;;
			esac
			owner="136693071363"
			;;
		"kali")
			case "$version" in
				"2023.1")
					case "$architecture" in
						"amd64")
							amiNamePattern="kali-linux-2023.1-amd64*"
							;;
						"arm64")
							amiNamePattern="kali-linux-2023.1-arm64*"
							;;
						*)
							echo "Unsupported architecture: $architecture for Kali"
							return 1
							;;
					esac
					;;
				*)
					echo "Unsupported version: $version for Kali"
					return 1
					;;
			esac
			owner="679593333241"
			;;
		*)
			echo "Unsupported distribution: $distro"
			return 1
			;;
	esac

	amiNamePattern=$(printf "$amiNamePattern" "$version")
	echo "Searching for AMIs with pattern: $amiNamePattern and owner: $owner"
	wait
	AMI_ID=$(aws ec2 describe-images \
        --filters "Name=name,Values=$amiNamePattern" \
        --owners "$owner" \
        --query 'sort_by(Images, &CreationDate)[-1].ImageId' \
        --output text)
	if [ -z "$AMI_ID" ]
	then
		echo "No images found for distro: $distro, version: $version, architecture: $architecture"
		return 1
	fi
	echo "$AMI_ID"
}

# List Instance Profiles
#
# Lists all instance profiles.
#
# Usage:
#   list_instance_profiles
#
# Output:
#   Outputs a list of instance profiles.
#
# Example(s):
#   list_instance_profiles
list_instance_profiles() {
    INSTANCE_PROFILE_NAMES=$(aws iam list-instance-profiles --query "InstanceProfiles[].InstanceProfileName" --output text | tr '\t' '\n')

    # For each instance profile, print the name
    for INSTANCE_PROFILE_NAME in $INSTANCE_PROFILE_NAMES; do
        echo "$INSTANCE_PROFILE_NAME"
    done
}

# Delete Instance Profiles
#
# Deletes instance profiles based on input criteria. It reads instance profile names
# from standard input (stdin) and performs the following actions:
# - Removes the role from the instance profile.
# - Deletes the instance profile itself.
#
# Usage:
#   Pipe the output of list_instance_profiles into this function to delete them.
#   Or provide a specific instance profile name as an argument to delete it.
#
# Input:
#   Instance profile names are expected to be read from stdin, one per line.
#   If a specific instance profile name is provided as an argument, it will be deleted.
#
# Output:
#   Outputs the actions taken for each instance profile, including removing roles
#   and deleting the instance profile. If any errors occur, they are also output.
#
# Example(s):
#   list_instance_profiles | delete_instance_profile
#   delete_instance_profile example-instance-profile
delete_instance_profile() {
    if [[ -n "$1" ]]; then
        echo "$1" | delete_instance_profile_from_input
    else
        delete_instance_profile_from_input
    fi
}

delete_instance_profile_from_input() {
    while IFS= read -r instance_profile_name; do
        # List the roles in the instance profile
        roles=$(aws iam get-instance-profile --instance-profile-name "$instance_profile_name" --query 'InstanceProfile.Roles[].RoleName' --output text)

        # Remove each role from the instance profile
        for role in $roles; do
            echo "Removing role $role from instance profile $instance_profile_name"
            aws iam remove-role-from-instance-profile --instance-profile-name "$instance_profile_name" --role-name "$role"
        done

        # Delete the instance profile
        echo "Deleting instance profile: $instance_profile_name"
        aws iam delete-instance-profile --instance-profile-name "$instance_profile_name"
    done
}

# List Running Instances
#
# Lists all running EC2 instances.
#
# Usage:
#   list_running_instances
#
# Output:
#   Outputs a table of running instances.
#
# Example(s):
#   list_running_instances
list_running_instances() {
  aws ec2 describe-instances \
    --query \
    "Reservations[*].Instances[*].{InstanceId:InstanceId, VPC:VpcId, Subnet:SubnetId, PublicIP:PublicIpAddress, PrivateIP:PrivateIpAddress, Name:Tags[?Key=='Name']|[0].Value}" \
    --filters Name=instance-state-name,Values=running --output json
}

# List Security Groups
#
# Lists security groups based on optional filters.
#
# Usage:
#   list_security_groups
#
# Output:
#   Lists the names of the security groups that match the specified filters, if any.
#   If no filters are specified, all security group names are listed, one per line.
#
# Example(s):
#   list_security_groups
#   list_security_groups "test-tt-test-*"
list_security_groups() {
    local filter="$1"
    local query_args=()

    # Check if a filter is provided and construct the query argument
    if [[ -n "$filter" ]]; then
        query_args=(--filters "Name=group-name,Values=$filter")
    fi

    # Attempt to list security groups with the given filter
    local group_names
    group_names=$(aws ec2 describe-security-groups "${query_args[@]}" --query 'SecurityGroups[*].GroupName' --output text)
    if [[ $? -eq 0 ]]; then
        echo "$group_names" | tr '\t' '\n'
    fi
}

# Delete Security Groups
#
# Deletes specified security groups by name or ID, including detaching network interfaces
# and removing rules.
#
# Usage:
#   delete_security_groups security_group_identifiers
#
# Output:
#   Deletes the specified security groups, handling dependencies.
#
# Example(s):
#   delete_security_groups "sg-0cec4d85ba446428c"
#   delete_security_groups "my-security-group"
#   delete_security_groups "arn:aws:ec2:us-east-1:123445667:security-group/sg-0123456789abcdef0"
delete_security_groups() {
    local search_pattern=$1

    # Get the security group IDs matching the pattern
    sg_ids=$(aws ec2 describe-security-groups \
        --filters Name=group-name,Values="$search_pattern" \
        --query "SecurityGroups[*].GroupId" \
        --output text)

    if [ -z "$sg_ids" ]; then
        echo "No security groups found for pattern $search_pattern."
        return
    fi

    # Iterate over each security group ID in parallel
    echo "$sg_ids" | tr '\t' '\n' | while IFS= read -r sg_id; do
        {
            sg_id=$(echo "$sg_id" | xargs)  # Trim any whitespace
            echo "Processing security group with ID $sg_id."

            # Remove all inbound rules
            inbound_rules=$(aws ec2 describe-security-groups \
                --group-ids "$sg_id" \
                --query 'SecurityGroups[0].IpPermissions' \
                --output json)
            if [ "$inbound_rules" != "[]" ]; then
                echo "Revoking inbound rules for security group $sg_id"
                aws ec2 revoke-security-group-ingress \
                    --group-id "$sg_id" \
                    --ip-permissions "$inbound_rules"
            fi

            # Remove all outbound rules
            outbound_rules=$(aws ec2 describe-security-groups \
                --group-ids "$sg_id" \
                --query 'SecurityGroups[0].IpPermissionsEgress' \
                --output json)
            if [ "$outbound_rules" != "[]" ]; then
                echo "Revoking outbound rules for security group $sg_id"
                aws ec2 revoke-security-group-egress \
                    --group-id "$sg_id" \
                    --ip-permissions "$outbound_rules"
            fi

            # Detach network interfaces
            network_interfaces=$(aws ec2 describe-network-interfaces \
                --filters Name=group-id,Values="$sg_id" \
                --query 'NetworkInterfaces[*].NetworkInterfaceId' \
                --output text)
            if [ -n "$network_interfaces" ]; then
                for ni in $network_interfaces; do
                    ni=$(echo "$ni" | xargs)  # Trim whitespace
                    echo "Detaching network interface $ni from security group $sg_id."
                    attachment_id=$(aws ec2 describe-network-interfaces \
                        --network-interface-ids "$ni" \
                        --query 'NetworkInterfaces[0].Attachment.AttachmentId' \
                        --output text)
                    if [ -n "$attachment_id" ]; then
                        aws ec2 detach-network-interface --attachment-id "$attachment_id"
                        aws ec2 delete-network-interface --network-interface-id "$ni"
                    fi
                done
            fi

            # Attempt to delete the security group with retries
            for attempt in {1..3}; do
                echo "Attempting to delete security group with ID $sg_id (Attempt $attempt)"
                if aws ec2 delete-security-group --group-id "$sg_id"; then
                    echo "Deleted security group with ID $sg_id on attempt $attempt."
                    break
                else
                    echo "Failed to delete security group with ID $sg_id on attempt $attempt. Retrying..."
                    sleep 5
                fi
            done
        } &
    done

    # Wait for all background processes to complete
    wait

    echo "Security groups processing completed."
}

# Terminate Instance
#
# Terminates a specified EC2 instance.
#
# Usage:
#   terminate_instance [instance_id]
#
# Output:
#   Terminates the instance if it's running. If it's already being terminated, the function skips it.
#   If the instance is in an unexpected state, it throws an error.
#
# Example(s):
#   terminate_instance "i-0abcd1234efgh5678"
terminate_instance () {
	local instance_id=$1
	while true
	do
		instance_status=$(aws ec2 describe-instances --instance-ids "$instance_id" --output json | jq -r '.Reservations[0].Instances[0].State.Name')
		if [ "$instance_status" = "terminated" ] || [ "$instance_status" = "shutting-down" ]
		then
			echo "Skipping instance $instance_id which is already $instance_status"
			break
		elif [ "$instance_status" = "running" ]
		then
			echo "Terminating instance: $instance_id"
			aws ec2 terminate-instances --instance-ids "$instance_id"
			break
		else
			echo "Unexpected instance status: $instance_status"
			exit 1
		fi
	done
}

# Wait for Command
#
# Waits for a previously run command to complete.
#
# Usage:
#   wait_for_command [command_id]
#
# Output:
#   No output, but pauses script execution until the specified command has finished running.
#
# Example(s):
#   wait_for_command "0abcd1234efgh5678"
wait_for_command() {
    local command_id=$1
    local command_status

    while true; do
        command_status=$(aws ssm list-command-invocations --command-id "$command_id" --details --query 'CommandInvocations[0].Status' --output text)

        if [ -z "$command_status" ]; then
            echo "Failed to fetch command status."
            exit 1
        elif [ "$command_status" = "Success" ]; then
            break
        elif [ "$command_status" = "Failed" ]; then
            echo "Command execution failed."
            exit 1
        fi

        echo "Waiting for command to finish..."
        sleep 5
    done
}

# Wait for Initialization
#
# Waits until the newly created EC2 instance changes its status
# from "initializing" to another state, signaling that initialization
# has completed.
#
# Usage:
#   wait_for_initialization
#
# Output:
#   No output, but pauses script execution until the EC2 instance has finished initializing.
#
# Example(s):
#   wait_for_initialization
wait_for_initialization() {
    instance_status="initializing"
    while [[ "$instance_status" == "initializing" || "$instance_status" == "null" ]]; do
        instance_status=$(aws ec2 describe-instance-status --instance-id "${INSTANCE_ID}" \
            | jq -r ".InstanceStatuses[0].InstanceStatus.Status")
        sleep 10
    done
}

# List VPCs
#
# Lists all VPCs with their ID, Name (if tagged), and State.
#
# Usage:
#   list_vpcs
#
# Output:
#   Outputs a table of VPCs with their ID, Name, and State.
#
# Example(s):
#   list_vpcs
list_vpcs() {
    echo "Listing VPCs..."
    aws ec2 describe-vpcs --query 'Vpcs[].{ID:VpcId, Name:Tags[?Key==`Name`]|[0].Value, State:State}' --output table
}

# Clear and Delete S3 Bucket
#
# Clears all versions of all objects and delete markers from the specified S3
# bucket, then deletes the bucket itself.
#
# Usage:
#   clear_and_delete_s3_bucket "bucket-name"
#   where "bucket-name" is the name of the S3 bucket you want to clear and delete.
#
# Output:
#   No direct output, but the specified S3 bucket and all its contents are irreversibly deleted.
#
# Example(s):
#   clear_and_delete_s3_bucket "my-example-bucket"
clear_and_delete_s3_bucket() {
    local bucket_name=$1

    echo "Clearing and deleting S3 bucket: $bucket_name"

    # Input validation
    if [ -z "$bucket_name" ]; then
        echo "No bucket name provided. Usage: clear_and_delete_s3_bucket <bucket-name>"
        return 1
    fi

    # Delete all versions of all objects in the bucket
    aws s3api list-object-versions --bucket "$bucket_name" | \
    jq -r '.Versions[] | .Key + " " + .VersionId' | \
    while read -r key version; do
        aws s3api delete-object --bucket "$bucket_name" --key "$key" --version-id "$version"
    done

    # Delete all delete markers
    aws s3api list-object-versions --bucket "$bucket_name" | \
    jq -r '.DeleteMarkers[] | .Key + " " + .VersionId' | \
    while read -r key version; do
        aws s3api delete-object --bucket "$bucket_name" --key "$key" --version-id "$version"
    done

    # Delete the bucket
    aws s3api delete-bucket --bucket "$bucket_name"

    echo "Successfully deleted S3 bucket: $bucket_name"
}

# Get Subnet Route Table
#
# Retrieves the route table ID associated with a specific subnet.
# It requires the subnet ID as input and returns the route table ID.
#
# Usage:
#   get_subnet_route_table "subnet-id"
#   where "subnet-id" is the ID of the subnet for which you want to get the associated route table.
#
# Output:
#   Outputs the route table ID associated with the specified subnet.
#   If the subnet ID is not provided or the command fails, an error message is shown.
#
# Example(s):
#   get_subnet_route_table "subnet-1234abcd"
get_subnet_route_table() {
    local subnet_id=$1
    local route_table_id

    if [[ -z "$subnet_id" ]]; then
        echo "No subnet ID provided. Usage: get_subnet_route_table <subnet-id>"
        return 1
    fi

    route_table_id=$(aws ec2 describe-route-tables \
        --filters "Name=association.subnet-id,Values=$subnet_id" \
        --query "RouteTables[].RouteTableId" \
        --output text)

    # Check if the AWS command was successful
    if [ $? -eq 0 ]; then
        echo "$route_table_id"
    else
        echo "Error fetching route table for subnet $subnet_id"
        return 1
    fi
}

# Is Subnet Public
#
# Determines whether a subnet is publicly routable based on the route table associated with it.
# It checks if there's a route to an Internet Gateway in the route table.
#
# Usage:
#   is_subnet_public "subnet-id"
#   where "subnet-id" is the ID of the subnet you want to check.
#
# Output:
#   Outputs "True" if the subnet has a route to an Internet Gateway, indicating it's public.
#   Outputs "False" if there's no such route, indicating the subnet is private.
#
# Example(s):
#   is_subnet_public "subnet-1234abcd"
is_subnet_public() {
    local subnet_id=$1
    local route_table_id
    local igw_route
    local result="False"

    if [[ -z "$subnet_id" ]]; then
        echo "No subnet ID provided. Usage: is_subnet_public <subnet-id>"
        return 1
    fi

    route_table_id=$(get_subnet_route_table "$subnet_id")
    if [[ -z "$route_table_id" || "$route_table_id" == "None" ]]; then
        echo "False"
        return
    fi

    igw_route=$(aws ec2 describe-route-tables --route-table-ids "$route_table_id" --query "RouteTables[*].Routes[?GatewayId && GatewayId!='local' && starts_with(GatewayId, 'igw-')]" --output text)

    if [[ ! -z "$igw_route" ]]; then
        result="True"
    fi

    echo "$result"
}

# List VPC Subnets
#
# Lists all subnets within a specified VPC and determines if each subnet is public or private.
# It requires the VPC ID as input and prints each subnet's ID along with its public/private status.
#
# Usage:
#   list_vpc_subnets "vpc-id"
#   where "vpc-id" is the ID of the VPC for which you want to list the subnets.
#
# Output:
#   Outputs a list of subnets with their IDs and whether they are public or private.
#
# Example(s):
#   list_vpc_subnets "vpc-1234abcd"
list_vpc_subnets() {
    local vpc_id=$1
    local subnets
    local is_public

    if [[ -z "$vpc_id" ]]; then
        echo "No VPC ID provided. Usage: list_vpc_subnets <vpc-id>"
        return 1
    fi

    echo "Getting subnets associated with $vpc_id..."
    subnets=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$vpc_id" --query "Subnets[].SubnetId" --output text | tr '\t' '\n')

    # Split the subnets into an array manually
    local subnet_array=()
    while IFS= read -r line; do
        subnet_array+=("$line")
    done <<< "$subnets"

    for subnet_id in "${subnet_array[@]}"; do
        if [[ -n "$subnet_id" ]]; then  # Check if subnet_id is not empty
            is_public=$(is_subnet_public "$subnet_id")
            if [[ $is_public == "True" ]]; then
                echo "$subnet_id is Public"
            else
                echo "$subnet_id is Private"
            fi
        fi
    done
}

# List IAM Policies and Group Policies for an IAM User
#
# Lists directly attached IAM policies and group policies for a specified IAM user.
# It fetches the attached policies directly linked to the user and policies
# attached to groups the user is part of.
#
# Usage:
#   list_iam_user_policies "user-name"
#   where "user-name" is the name of the IAM user you want to check.
#
# Output:
#   Outputs the policies directly attached to the user and the policies
#   attached to the groups the user is part of.
#
# Example(s):
#   list_iam_user_policies "my-iam-user"
list_iam_user_policies() {
    local user_name=$1

    # Prevent aws cli from using a pager for output
    export AWS_PAGER=""

    if [[ -z "$user_name" ]]; then
        echo "No IAM User name provided. Usage: list_iam_user_policies <user-name>"
        return 1
    fi

    echo "Getting policies attached directly to the IAM User: $user_name"
    aws iam list-attached-user-policies --user-name "$user_name" --output json

    echo "Getting IAM Groups the user is a member of:"
    local groups
    groups=$(aws iam list-groups-for-user --user-name "$user_name" --query 'Groups[].GroupName' --output json)

    # Parse the group names and fetch policies for each group
    local group_names
    group_names=$(echo "$groups" | jq -r '.[]')

    for group_name in $group_names; do
        echo "Getting policies attached to the group: $group_name"
        aws iam list-attached-group-policies --group-name "$group_name" --output json
    done
}

# Delete Unused Elastic IPs (EIPs)
#
# Deletes all Elastic IP addresses (EIPs) that are not associated with any running instances.
# This function uses AWS CLI to find and release any unassociated EIPs, helping to avoid unnecessary charges.
#
# Usage:
#   delete_unused_eips
#   No arguments are required. Simply run the function to check and release all unassociated EIPs.
#
# Output:
#   For each EIP released, it outputs a success message with the allocation ID of the released EIP.
#   If an EIP cannot be released, it outputs a failure message with the allocation ID.
#
# Example(s):
#   delete_unused_eips
delete_unused_eips() {
    echo "Deleting all unused EIPs..."

    # Get all unused EIPs, output in JSON, then parse with jq
    aws ec2 describe-addresses --query 'Addresses[?InstanceId==null].AllocationId' --output json | jq -r '.[]' | while IFS= read -r id; do
        if [ -n "$id" ]; then
            # Delete the EIP
            aws ec2 release-address --allocation-id "$id" && echo "Successfully deleted EIP with allocation ID: $id" || echo "Failed to delete EIP with allocation ID: $id"
        fi
    done

    echo "Finished deleting all unused EIPs."
}

# Detach an IAM policy from all entities and delete it
#
# Detaches the specified IAM policy from all roles it's attached to and then deletes the policy.
#
# Usage:
#   detach_delete_iam_policy "arn:aws:iam::accountID:policy/policy-name"
#   where "arn:aws:iam::accountID:policy/policy-name" is the ARN of the IAM policy you want to detach and delete.
#
# Output:
#   Detaches the policy from all roles and deletes it.
#
# Example(s):
#
#   AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
#   detach_delete_iam_policy "arn:aws:iam::$AWS_ACCOUNT_ID:policy/test-eks-...."
detach_delete_iam_policy() {
    local policy_arn=$1

    if [[ -z "$policy_arn" ]]; then
        echo "No policy ARN provided. Usage: detach_delete_iam_policy <policy-arn>"
        return 1
    fi

    # List roles attached to the policy
    local attached_roles
    attached_roles=$(aws iam list-entities-for-policy --policy-arn "$policy_arn" --query 'PolicyRoles[].RoleName' --output text)

    # Detach policy from each role
    for role_name in $attached_roles; do
        echo "Detaching policy from role: $role_name"
        aws iam detach-role-policy --role-name "$role_name" --policy-arn "$policy_arn"
    done

    # Delete the policy
    echo "Deleting policy: $policy_arn"
    aws iam delete-policy --policy-arn "$policy_arn"
}

# Find IAM resources with a specific keyword in their name or tag
#
# Searches for IAM users, roles, policies, and groups that have a specific
# keyword in their name or tag. The keyword is provided as an input string to the function
# and is case-insensitive.
#
# Usage:
#   find_iam_resources_with_keyword "keyword"
#   where "keyword" is the string you want to search for in the name or tag of IAM resources.
#
# Output:
#   Lists the IAM resources that match the keyword in their name or tag.
#
# Example(s):
#   find_iam_resources_with_keyword "terratest-"
find_iam_resources_with_keyword() {
    input_string=$1
    if [[ -z "$input_string" ]]; then
        echo "No input string provided. Usage: find_iam_resources_with_keyword <keyword>"
        return 1
    fi

    input_string=$(echo "$1" | tr '[:upper:]' '[:lower:]')  # Convert input string to lowercase using tr

    local resource_types=("user" "role" "policy" "group")

    echo "Searching for IAM resources with '$input_string' in the name or tag..."

    for resource_type in "${resource_types[@]}"; do
        echo "Checking IAM $resource_type(s)..."
        case $resource_type in
        "user")
            # List IAM users with keyword in the name
            aws iam list-users --query "Users[].[UserName, UserId, CreateDate, Path]" --output text | grep -i "$input_string"
            ;;
        "role")
            # List IAM roles with keyword in the name
            aws iam list-roles --query "Roles[].[RoleName, Arn, CreateDate, Description, MaxSessionDuration, Path, RoleId, RoleName]" --output text | grep -i "$input_string"
            ;;
        "policy")
            # List IAM policies with keyword in the name
            aws iam list-policies --query "Policies[].[PolicyName, Arn, CreateDate, DefaultVersionId, Path, PolicyId]" --output text | grep -i "$input_string"
            ;;
        "group")
            # List IAM groups with keyword in the name
            aws iam list-groups --query "Groups[].[GroupName, Arn, CreateDate, Path]" --output text | grep -i "$input_string"
            ;;
        esac
    done

    echo "Finished searching for IAM resources."
}

# Cleans up IAM resources based on input criteria
#
# This function processes IAM resources that match specified criteria. It reads
# resource names (roles and policies) from standard input (stdin) and performs
# the following actions:
# - For roles:
#   - Removes the role from any instance profiles it's associated with.
#   - Detaches all managed policies attached to the role.
#   - Deletes all inline policies attached to the role.
#   - Attempts to delete the role itself.
# - For policies:
#   - Detaches the policy from any roles it's attached to.
#   - Deletes the policy.
#
# Usage:
#   Pipe the output of a command that lists IAM roles and policies into this function
#   to clean them up. Ensure each line of the input contains the ARN of one IAM resource.
#   Example: find_iam_resources_with_keyword 'terratest-' | clean_up_iam_resources
#
# Input:
#   Resource ARNs are expected to be read from stdin, one per line. Each
#   resource ARN should meet the criteria for processing
#   (e.g., prefixed with "terratest-" or belonging to a specific AWS account).
#
# Output:
#   Outputs the actions taken for each resource, including detaching and deleting
#   policies, removing roles from instance profiles, and deleting roles. If any
#   errors occur, they are also output.
#
# Example(s):
#   echo "arn:aws:iam::123456789012:role/terratest-example-role" | clean_up_iam_resources
#   This example processes a single role named "terratest-example-role", removing
#   it from any instance profiles, detaching and deleting policies, and then deleting the role.
#
#   echo "arn:aws:iam::123456789012:policy/terratest-example-policy" | clean_up_iam_resources
#   This example processes a single policy named "terratest-example-policy", detaching it
#   from any roles and then deleting the policy.
clean_up_iam_resources() {
    while IFS= read -r line; do
        resource_arn=$(echo "$line" | awk '{print $1}')

        if [[ "$resource_arn" =~ ^arn:aws:iam::[0-9]+:policy/.+ ]]; then
            policy_arn=$resource_arn
            roles=$(aws iam list-entities-for-policy --policy-arn "$policy_arn" --query 'PolicyRoles[].RoleName' --output text)
            for role in $roles; do
                echo "Detaching policy $policy_arn from $role"
                aws iam detach-role-policy --role-name "$role" --policy-arn "$policy_arn"
            done
            echo "Deleting policy: $policy_arn"
            aws iam delete-policy --policy-arn "$policy_arn"
        elif [[ "$resource_arn" =~ ^arn:aws:iam::[0-9]+:role/.+ ]]; then
            role_name=$(echo "$resource_arn" | awk -F'/' '{print $2}')
            instance_profiles=$(aws iam list-instance-profiles-for-role --role-name "$role_name" --query 'InstanceProfiles[].InstanceProfileName' --output text)
            for profile in $instance_profiles; do
                echo "Removing role $role_name from instance profile $profile"
                aws iam remove-role-from-instance-profile --instance-profile-name "$profile" --role-name "$role_name"
            done
            policies=$(aws iam list-attached-role-policies --role-name "$role_name" --query 'AttachedPolicies[].PolicyArn' --output text)
            for policy_arn in $policies; do
                echo "Detaching policy $policy_arn from $role_name"
                aws iam detach-role-policy --role-name "$role_name" --policy-arn "$policy_arn"
            done
            inline_policies=$(aws iam list-role-policies --role-name "$role_name" --query 'PolicyNames' --output text)
            for policy_name in $inline_policies; do
                echo "Deleting inline policy $policy_name from $role_name"
                aws iam delete-role-policy --role-name "$role_name" --policy-name "$policy_name"
            done
            echo "Attempting to delete role: $role_name"
            if aws iam delete-role --role-name "$role_name"; then
                echo "Successfully deleted role: $role_name"
            else
                echo "Failed to delete role: $role_name. Check for any remaining dependencies."
            fi
        else
            echo "Invalid resource ARN: $resource_arn"
        fi
    done
}

# Deletes an EKS cluster and its associated node groups
#
# This function deletes an Amazon EKS cluster and all of its associated node groups.
# The name of the EKS cluster to delete is provided as an input string to the function.
#
# Usage:
#   delete_eks_cluster_and_node_groups "cluster-name"
#   where "cluster-name" is the name of the EKS cluster you want to delete.
#
# Output:
#   Outputs the progress of deleting the node groups and the EKS cluster, including
#   waiting for each deletion to complete.
#
# Example(s):
#   delete_eks_cluster_and_node_groups "test-tt-test-wndq2t"
delete_eks_cluster_and_node_groups() {
    local CLUSTER_NAME=$1

    if [[ -z "$CLUSTER_NAME" ]]; then
        echo "No cluster name provided. Usage: delete_eks_cluster_and_node_groups <cluster-name>"
        return 1
    fi

    # Get the list of node groups associated with the cluster
    local NODE_GROUPS
    NODE_GROUPS=$(aws eks list-nodegroups --cluster-name "$CLUSTER_NAME" --query 'nodegroups[*]' --output text)

    # Delete each node group
    for NODE_GROUP in $NODE_GROUPS; do
        echo "Deleting node group $NODE_GROUP from cluster $CLUSTER_NAME..."
        aws eks delete-nodegroup --cluster-name "$CLUSTER_NAME" --nodegroup-name "$NODE_GROUP"
        echo "Waiting for node group $NODE_GROUP to be deleted..."
        aws eks wait nodegroup-deleted --cluster-name "$CLUSTER_NAME" --nodegroup-name "$NODE_GROUP"
    done

    # Delete the EKS cluster
    echo "Deleting EKS cluster $CLUSTER_NAME..."
    aws eks delete-cluster --name "$CLUSTER_NAME"
    echo "Waiting for EKS cluster $CLUSTER_NAME to be deleted..."
    aws eks wait cluster-deleted --name "$CLUSTER_NAME"

    echo "EKS cluster $CLUSTER_NAME and its node groups have been successfully deleted."
}

# Deletes KMS keys with a specific string in their alias
#
# This function searches for AWS KMS keys with a specific string in their alias name
# and deletes them. The search string is provided as an input to the function.
# The function lists aliases containing the search string, retrieves the associated key IDs,
# schedules the keys for deletion, and deletes the aliases.
#
# Usage:
#   delete_kms_keys_with_string "search-string"
#   where "search-string" is the string you want to search for in the KMS alias names.
#
# Output:
#   Outputs the progress of deleting each KMS key and its associated alias, including
#   scheduling the deletion of keys and deleting the aliases.
#
# Example(s):
#   Search for and delete KMS keys with "tt-test" in their alias:
#   delete_kms_keys_with_string "tt-test"
#
#   Delete all KMS keys with an empty string in their alias:
#   delete_kms_keys_with_string ' '
delete_kms_keys_with_string() {
    local search_string=$1

    if [[ -z "$search_string" ]]; then
        echo "No search string provided. Usage: delete_kms_keys_with_string <string>"
        return 1
    fi

    # Get a list of KMS aliases with the search string in the name
    local ALIAS_LIST
    if [[ "$search_string" == " " ]]; then
        # Only select aliases that are exactly a single space
        ALIAS_LIST=$(aws kms list-aliases --region "$AWS_DEFAULT_REGION" \
            --query "Aliases[?AliasName==' '].AliasName" --output text)
    else
        ALIAS_LIST=$(aws kms list-aliases --region "$AWS_DEFAULT_REGION" \
            --query "Aliases[?contains(AliasName, \`$search_string\`)].AliasName" --output text)
    fi

    # Process each alias in parallel
    echo "$ALIAS_LIST" | tr '\t' '\n' | while IFS= read -r ALIAS; do
        {
            if [[ -n "$ALIAS" ]]; then
                echo "Processing alias: $ALIAS"

                # Get the key ID associated with the alias
                KEY_ID=$(aws kms list-aliases --region "$AWS_DEFAULT_REGION" \
                    --query "Aliases[?AliasName=='$ALIAS'].TargetKeyId" --output text)

                if [[ -n "$KEY_ID" ]]; then
                    echo "Deleting key with alias: $ALIAS and key ID: $KEY_ID"

                    # Schedule key deletion (keys are not deleted immediately but scheduled for deletion)
                    aws kms schedule-key-deletion --key-id "$KEY_ID" --pending-window-in-days 7 --region "$AWS_DEFAULT_REGION"

                    echo "Scheduled deletion for key ID: $KEY_ID"

                    # Delete the alias
                    aws kms delete-alias --alias-name "$ALIAS" --region "$AWS_DEFAULT_REGION"

                    echo "Deleted alias: $ALIAS"
                else
                    echo "No key associated with alias: $ALIAS"
                fi
            fi
        } &
    done

    # Wait for all background processes to complete
    wait
}

# Cleans up S3 buckets based on input criteria
#
# This function lists and deletes S3 buckets that match a specified criteria. It deletes all objects
# (including versions and delete markers) within the bucket before deleting the bucket itself.
#
# Usage:
#   clean_up_s3_buckets "bucket-selection-criteria"
#   where "bucket-selection-criteria" is the string used to match bucket names.
#
# Output:
#   Outputs the progress of deleting objects and the bucket, including any errors encountered.
#
# Example(s):
#   clean_up_s3_buckets "pt-fleet-admiral"
clean_up_s3_buckets() {
    local bucket_selection_criteria=$1

    if [[ -z "$bucket_selection_criteria" ]]; then
        echo "No bucket selection criteria provided. Usage: clean_up_s3_buckets <bucket-selection-criteria>"
        return 1
    fi

    # List all buckets with the selection criteria
    local buckets=()
    while IFS= read -r line; do
        buckets+=("$line")
    done < <(aws s3 ls | grep -i "$bucket_selection_criteria" | awk '{print $3}')

    for bucket in "${buckets[@]}"; do
        (
            echo "Deleting objects from bucket: ${bucket}"

            # Remove all versions of all objects from the bucket
            aws s3api list-object-versions --bucket "$bucket" --output json | jq -r '.Versions[] | .Key + " " + .VersionId' | xargs -P 10 -n 2 aws s3api delete-object --bucket "$bucket" --key {} --version-id {}

            # Remove all delete markers (needed for versioned buckets)
            aws s3api list-object-versions --bucket "$bucket" --output json | jq -r '.DeleteMarkers[] | .Key + " " + .VersionId' | xargs -P 10 -n 2 aws s3api delete-object --bucket "$bucket" --key {} --version-id {}

            echo "Deleting bucket: ${bucket}"

            # Delete the bucket
            aws s3 rb s3://"$bucket" --force
        ) &
    done
    wait
}
