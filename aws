# Download Bucket
#
# Syncs the contents of the specified Amazon S3 bucket to the
# specified local destination directory or to the current directory
# if no destination is provided.
#
# Usage:
#   download_bucket [bucket-name] [destination-directory]
#
# Output:
#   Syncs the files from the S3 bucket to the local destination.
#
# Example(s):
#   download_bucket "mybucket" "$HOME"
#   download_bucket "mybucket"
download_bucket() {
	bucket="${1}"
	if [[ -z "${bucket}" ]]; then
		echo "You need to supply a bucket!"
		echo "Example: download_bucket mybucket $HOME"
		return 1
	fi
	dest="${2}"
	if [[ -z "${dest}" ]]; then
		dest='.'
	fi

	aws s3 sync "s3://${1}" "${dest}"
}

# Find Default Subnet
#
# Finds the default subnet ID.
#
# Usage:
#   find_default_subnet
#
# Output:
#   Outputs the default subnet ID.
#
# Example(s):
#   find_default_subnet
function find_default_subnet() {
    aws ec2 describe-subnets \
        --filters "Name=default-for-az,Values=true" \
        --output text --query 'Subnets[0].SubnetId'
}

# Find Default VPC
#
# Finds the default VPC ID.
#
# Usage:
#   find_default_vpc
#
# Output:
#   Outputs the default VPC ID.
#
# Example(s):
#   find_default_vpc
find_default_vpc() {
  aws ec2 describe-vpcs \
    --filters "Name=isDefault,Values=true" \
    --output text --query 'Vpcs[0].VpcId'
}







# List Instance Profiles
#
# Lists all instance profiles.
#
# Usage:
#   list_instance_profiles
#
# Output:
#   Outputs a list of instance profiles.
#
# Example(s):
#   list_instance_profiles
list_instance_profiles() {
    INSTANCE_PROFILE_NAMES=$(aws iam list-instance-profiles --query "InstanceProfiles[].InstanceProfileName" --output text | tr '\t' '\n')

    # For each instance profile, print the name
    for INSTANCE_PROFILE_NAME in $INSTANCE_PROFILE_NAMES; do
        echo "$INSTANCE_PROFILE_NAME"
    done
}

# Delete Instance Profiles
#
# Deletes instance profiles based on input criteria. It reads instance profile names
# from standard input (stdin) and performs the following actions:
# - Removes the role from the instance profile.
# - Deletes the instance profile itself.
#
# Usage:
#   Pipe the output of list_instance_profiles into this function to delete them.
#   Or provide a specific instance profile name as an argument to delete it.
#
# Input:
#   Instance profile names are expected to be read from stdin, one per line.
#   If a specific instance profile name is provided as an argument, it will be deleted.
#
# Output:
#   Outputs the actions taken for each instance profile, including removing roles
#   and deleting the instance profile. If any errors occur, they are also output.
#
# Example(s):
#   list_instance_profiles | delete_instance_profile
#   delete_instance_profile example-instance-profile
delete_instance_profile() {
    if [[ -n "$1" ]]; then
        echo "$1" | delete_instance_profile_from_input
    else
        delete_instance_profile_from_input
    fi
}

delete_instance_profile_from_input() {
    while IFS= read -r instance_profile_name; do
        # List the roles in the instance profile
        roles=$(aws iam get-instance-profile --instance-profile-name "$instance_profile_name" --query 'InstanceProfile.Roles[].RoleName' --output text)

        # Remove each role from the instance profile
        for role in $roles; do
            echo "Removing role $role from instance profile $instance_profile_name"
            aws iam remove-role-from-instance-profile --instance-profile-name "$instance_profile_name" --role-name "$role"
        done

        # Delete the instance profile
        echo "Deleting instance profile: $instance_profile_name"
        aws iam delete-instance-profile --instance-profile-name "$instance_profile_name"
    done
}

# Wait for Command
#
# Waits for a previously run command to complete.
#
# Usage:
#   wait_for_command [command_id]
#
# Output:
#   No output, but pauses script execution until the specified command has finished running.
#
# Example(s):
#   wait_for_command "0abcd1234efgh5678"
wait_for_command() {
    local command_id=$1
    local command_status

    while true; do
        command_status=$(aws ssm list-command-invocations --command-id "$command_id" --details --query 'CommandInvocations[0].Status' --output text)

        if [ -z "$command_status" ]; then
            echo "Failed to fetch command status."
            exit 1
        elif [ "$command_status" = "Success" ]; then
            break
        elif [ "$command_status" = "Failed" ]; then
            echo "Command execution failed."
            exit 1
        fi

        echo "Waiting for command to finish..."
        sleep 5
    done
}

# List VPCs
#
# Lists all VPCs with their ID, Name (if tagged), and State.
#
# Usage:
#   list_vpcs
#
# Output:
#   Outputs a table of VPCs with their ID, Name, and State.
#
# Example(s):
#   list_vpcs
list_vpcs() {
    echo "Listing VPCs..."
    aws ec2 describe-vpcs --query 'Vpcs[].{ID:VpcId, Name:Tags[?Key==`Name`]|[0].Value, State:State}' --output table
}

# Clean Up and Delete S3 Buckets Based on Criteria
#
# This function lists and deletes S3 buckets that match a specified selection criteria.
# It first deletes all objects (including versions and delete markers) within each bucket,
# and then deletes the bucket itself. The deletion process is done in parallel for efficiency.
#
# Usage:
#   clear_and_delete_s3_buckets "bucket-selection-criteria"
#   where "bucket-selection-criteria" is the string used to match bucket names.
#
# Output:
#   Outputs the progress of deleting objects and buckets, including any errors encountered.
#
# Example(s):
#   clear_and_delete_s3_buckets "ttpforge-bucket"
#   clear_and_delete_s3_buckets "attack-box-bucket"
#   clear_and_delete_s3_buckets "atomic-red-team-bucket"
#   clear_and_delete_s3_buckets "my-example-bucket"
clear_and_delete_s3_buckets() {
    local bucket_selection_criteria=$1

    if [[ -z "$bucket_selection_criteria" ]]; then
        echo "No bucket selection criteria provided. Usage: clean_up_s3_buckets <bucket-selection-criteria>"
        return 1
    fi

    # List all buckets that match the selection criteria
    local buckets=()
    while IFS= read -r line; do
        buckets+=("$line")
    done < <(aws s3 ls | grep -i "$bucket_selection_criteria" | awk '{print $3}')

    # Iterate through each bucket and delete its contents and the bucket itself
    for bucket in "${buckets[@]}"; do
        (
            echo "Deleting objects from bucket: ${bucket}"

            # Remove all versions of all objects from the bucket
            aws s3api list-object-versions --bucket "$bucket" --output json | jq -r '.Versions[] | .Key + " " + .VersionId' | xargs -P 10 -n 2 aws s3api delete-object --bucket "$bucket" --key {} --version-id {}

            # Remove all delete markers (needed for versioned buckets)
            aws s3api list-object-versions --bucket "$bucket" --output json | jq -r '.DeleteMarkers[] | .Key + " " + .VersionId' | xargs -P 10 -n 2 aws s3api delete-object --bucket "$bucket" --key {} --version-id {}

            echo "Deleting bucket: ${bucket}"

            # Delete the bucket
            aws s3 rb s3://"$bucket" --force
        ) &
    done
    wait
}

# Get Subnet Route Table
#
# Retrieves the route table ID associated with a specific subnet.
# It requires the subnet ID as input and returns the route table ID.
#
# Usage:
#   get_subnet_route_table "subnet-id"
#   where "subnet-id" is the ID of the subnet for which you want to get the associated route table.
#
# Output:
#   Outputs the route table ID associated with the specified subnet.
#   If the subnet ID is not provided or the command fails, an error message is shown.
#
# Example(s):
#   get_subnet_route_table "subnet-1234abcd"
get_subnet_route_table() {
    local subnet_id=$1
    local route_table_id

    if [[ -z "$subnet_id" ]]; then
        echo "No subnet ID provided. Usage: get_subnet_route_table <subnet-id>"
        return 1
    fi

    route_table_id=$(aws ec2 describe-route-tables \
        --filters "Name=association.subnet-id,Values=$subnet_id" \
        --query "RouteTables[].RouteTableId" \
        --output text)

    # Check if the AWS command was successful
    if [ $? -eq 0 ]; then
        echo "$route_table_id"
    else
        echo "Error fetching route table for subnet $subnet_id"
        return 1
    fi
}

# Is Subnet Public
#
# Determines whether a subnet is publicly routable based on the route table associated with it.
# It checks if there's a route to an Internet Gateway in the route table.
#
# Usage:
#   is_subnet_public "subnet-id"
#   where "subnet-id" is the ID of the subnet you want to check.
#
# Output:
#   Outputs "True" if the subnet has a route to an Internet Gateway, indicating it's public.
#   Outputs "False" if there's no such route, indicating the subnet is private.
#
# Example(s):
#   is_subnet_public "subnet-1234abcd"
is_subnet_public() {
    local subnet_id=$1
    local route_table_id
    local igw_route
    local result="False"

    if [[ -z "$subnet_id" ]]; then
        echo "No subnet ID provided. Usage: is_subnet_public <subnet-id>"
        return 1
    fi

    route_table_id=$(get_subnet_route_table "$subnet_id")
    if [[ -z "$route_table_id" || "$route_table_id" == "None" ]]; then
        echo "False"
        return
    fi

    igw_route=$(aws ec2 describe-route-tables --route-table-ids "$route_table_id" --query "RouteTables[*].Routes[?GatewayId && GatewayId!='local' && starts_with(GatewayId, 'igw-')]" --output text)

    if [[ ! -z "$igw_route" ]]; then
        result="True"
    fi

    echo "$result"
}

# List VPC Subnets
#
# Lists all subnets within a specified VPC and determines if each subnet is public or private.
# It requires the VPC ID as input and prints each subnet's ID along with its public/private status.
#
# Usage:
#   list_vpc_subnets "vpc-id"
#   where "vpc-id" is the ID of the VPC for which you want to list the subnets.
#
# Output:
#   Outputs a list of subnets with their IDs and whether they are public or private.
#
# Example(s):
#   list_vpc_subnets "vpc-1234abcd"
list_vpc_subnets() {
    local vpc_id=$1
    local subnets
    local is_public

    if [[ -z "$vpc_id" ]]; then
        echo "No VPC ID provided. Usage: list_vpc_subnets <vpc-id>"
        return 1
    fi

    echo "Getting subnets associated with $vpc_id..."
    subnets=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$vpc_id" --query "Subnets[].SubnetId" --output text | tr '\t' '\n')

    # Split the subnets into an array manually
    local subnet_array=()
    while IFS= read -r line; do
        subnet_array+=("$line")
    done <<< "$subnets"

    for subnet_id in "${subnet_array[@]}"; do
        if [[ -n "$subnet_id" ]]; then  # Check if subnet_id is not empty
            is_public=$(is_subnet_public "$subnet_id")
            if [[ $is_public == "True" ]]; then
                echo "$subnet_id is Public"
            else
                echo "$subnet_id is Private"
            fi
        fi
    done
}

# List IAM Policies and Group Policies for an IAM User
#
# Lists directly attached IAM policies and group policies for a specified IAM user.
# It fetches the attached policies directly linked to the user and policies
# attached to groups the user is part of.
#
# Usage:
#   list_iam_user_policies "user-name"
#   where "user-name" is the name of the IAM user you want to check.
#
# Output:
#   Outputs the policies directly attached to the user and the policies
#   attached to the groups the user is part of.
#
# Example(s):
#   list_iam_user_policies "my-iam-user"
list_iam_user_policies() {
    local user_name=$1

    # Prevent aws cli from using a pager for output
    export AWS_PAGER=""

    if [[ -z "$user_name" ]]; then
        echo "No IAM User name provided. Usage: list_iam_user_policies <user-name>"
        return 1
    fi

    echo "Getting policies attached directly to the IAM User: $user_name"
    aws iam list-attached-user-policies --user-name "$user_name" --output json

    echo "Getting IAM Groups the user is a member of:"
    local groups
    groups=$(aws iam list-groups-for-user --user-name "$user_name" --query 'Groups[].GroupName' --output json)

    # Parse the group names and fetch policies for each group
    local group_names
    group_names=$(echo "$groups" | jq -r '.[]')

    for group_name in $group_names; do
        echo "Getting policies attached to the group: $group_name"
        aws iam list-attached-group-policies --group-name "$group_name" --output json
    done
}

# Delete Unused Elastic IPs (EIPs)
#
# Deletes all Elastic IP addresses (EIPs) that are not associated with any running instances.
# This function uses AWS CLI to find and release any unassociated EIPs, helping to avoid unnecessary charges.
#
# Usage:
#   delete_unused_eips
#   No arguments are required. Simply run the function to check and release all unassociated EIPs.
#
# Output:
#   For each EIP released, it outputs a success message with the allocation ID of the released EIP.
#   If an EIP cannot be released, it outputs a failure message with the allocation ID.
#
# Example(s):
#   delete_unused_eips
delete_unused_eips() {
    echo "Deleting all unused EIPs..."

    # Get all unused EIPs, output in JSON, then parse with jq
    aws ec2 describe-addresses --query 'Addresses[?InstanceId==null].AllocationId' --output json | jq -r '.[]' | while IFS= read -r id; do
        if [ -n "$id" ]; then
            # Delete the EIP
            aws ec2 release-address --allocation-id "$id" && echo "Successfully deleted EIP with allocation ID: $id" || echo "Failed to delete EIP with allocation ID: $id"
        fi
    done

    echo "Finished deleting all unused EIPs."
}

# Detach an IAM policy from all entities and delete it
#
# Detaches the specified IAM policy from all roles it's attached to and then deletes the policy.
#
# Usage:
#   detach_delete_iam_policy "arn:aws:iam::accountID:policy/policy-name"
#   where "arn:aws:iam::accountID:policy/policy-name" is the ARN of the IAM policy you want to detach and delete.
#
# Output:
#   Detaches the policy from all roles and deletes it.
#
# Example(s):
#
#   AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
#   detach_delete_iam_policy "arn:aws:iam::$AWS_ACCOUNT_ID:policy/test-eks-...."
detach_delete_iam_policy() {
    local policy_arn=$1

    if [[ -z "$policy_arn" ]]; then
        echo "No policy ARN provided. Usage: detach_delete_iam_policy <policy-arn>"
        return 1
    fi

    # List roles attached to the policy
    local attached_roles
    attached_roles=$(aws iam list-entities-for-policy --policy-arn "$policy_arn" --query 'PolicyRoles[].RoleName' --output text)

    # Detach policy from each role
    for role_name in $attached_roles; do
        echo "Detaching policy from role: $role_name"
        aws iam detach-role-policy --role-name "$role_name" --policy-arn "$policy_arn"
    done

    # Delete the policy
    echo "Deleting policy: $policy_arn"
    aws iam delete-policy --policy-arn "$policy_arn"
}

# Find IAM resources with a specific keyword in their name or tag
#
# Searches for IAM users, roles, policies, and groups that have a specific
# keyword in their name or tag. The keyword is provided as an input string to the function
# and is case-insensitive.
#
# Usage:
#   find_iam_resources_with_keyword "keyword"
#   where "keyword" is the string you want to search for in the name or tag of IAM resources.
#
# Output:
#   Lists the IAM resources that match the keyword in their name or tag.
#
# Example(s):
#   find_iam_resources_with_keyword "terratest-"
find_iam_resources_with_keyword() {
    input_string=$1
    if [[ -z "$input_string" ]]; then
        echo "No input string provided. Usage: find_iam_resources_with_keyword <keyword>"
        return 1
    fi

    input_string=$(echo "$1" | tr '[:upper:]' '[:lower:]')  # Convert input string to lowercase using tr

    local resource_types=("user" "role" "policy" "group")

    echo "Searching for IAM resources with '$input_string' in the name or tag..."

    for resource_type in "${resource_types[@]}"; do
        echo "Checking IAM $resource_type(s)..."
        case $resource_type in
        "user")
            # List IAM users with keyword in the name
            aws iam list-users --query "Users[].[UserName, UserId, CreateDate, Path]" --output text | grep -i "$input_string"
            ;;
        "role")
            # List IAM roles with keyword in the name
            aws iam list-roles --query "Roles[].[RoleName, Arn, CreateDate, Description, MaxSessionDuration, Path, RoleId, RoleName]" --output text | grep -i "$input_string"
            ;;
        "policy")
            # List IAM policies with keyword in the name
            aws iam list-policies --query "Policies[].[PolicyName, Arn, CreateDate, DefaultVersionId, Path, PolicyId]" --output text | grep -i "$input_string"
            ;;
        "group")
            # List IAM groups with keyword in the name
            aws iam list-groups --query "Groups[].[GroupName, Arn, CreateDate, Path]" --output text | grep -i "$input_string"
            ;;
        esac
    done

    echo "Finished searching for IAM resources."
}

# Cleans up IAM resources based on input criteria
#
# This function processes IAM resources that match specified criteria. It reads
# resource names (roles and policies) from standard input (stdin) and performs
# the following actions:
# - For roles:
#   - Removes the role from any instance profiles it's associated with.
#   - Detaches all managed policies attached to the role.
#   - Deletes all inline policies attached to the role.
#   - Attempts to delete the role itself.
# - For policies:
#   - Detaches the policy from any roles it's attached to.
#   - Deletes the policy.
#
# Usage:
#   Pipe the output of a command that lists IAM roles and policies into this function
#   to clean them up. Ensure each line of the input contains the ARN of one IAM resource.
#   Example: find_iam_resources_with_keyword 'terratest-' | clean_up_iam_resources
#
# Input:
#   Resource ARNs are expected to be read from stdin, one per line. Each
#   resource ARN should meet the criteria for processing
#   (e.g., prefixed with "terratest-" or belonging to a specific AWS account).
#
# Output:
#   Outputs the actions taken for each resource, including detaching and deleting
#   policies, removing roles from instance profiles, and deleting roles. If any
#   errors occur, they are also output.
#
# Example(s):
#   echo "arn:aws:iam::123456789012:role/terratest-example-role" | clean_up_iam_resources
#   This example processes a single role named "terratest-example-role", removing
#   it from any instance profiles, detaching and deleting policies, and then deleting the role.
#
#   echo "arn:aws:iam::123456789012:policy/terratest-example-policy" | clean_up_iam_resources
#   This example processes a single policy named "terratest-example-policy", detaching it
#   from any roles and then deleting the policy.
clean_up_iam_resources() {
    while IFS= read -r line; do
        resource_arn=$(echo "$line" | awk '{print $1}')

        if [[ "$resource_arn" =~ ^arn:aws:iam::[0-9]+:policy/.+ ]]; then
            policy_arn=$resource_arn
            roles=$(aws iam list-entities-for-policy --policy-arn "$policy_arn" --query 'PolicyRoles[].RoleName' --output text)
            for role in $roles; do
                echo "Detaching policy $policy_arn from $role"
                aws iam detach-role-policy --role-name "$role" --policy-arn "$policy_arn"
            done
            echo "Deleting policy: $policy_arn"
            aws iam delete-policy --policy-arn "$policy_arn"
        elif [[ "$resource_arn" =~ ^arn:aws:iam::[0-9]+:role/.+ ]]; then
            role_name=$(echo "$resource_arn" | awk -F'/' '{print $2}')
            instance_profiles=$(aws iam list-instance-profiles-for-role --role-name "$role_name" --query 'InstanceProfiles[].InstanceProfileName' --output text)
            for profile in $instance_profiles; do
                echo "Removing role $role_name from instance profile $profile"
                aws iam remove-role-from-instance-profile --instance-profile-name "$profile" --role-name "$role_name"
            done
            policies=$(aws iam list-attached-role-policies --role-name "$role_name" --query 'AttachedPolicies[].PolicyArn' --output text)
            for policy_arn in $policies; do
                echo "Detaching policy $policy_arn from $role_name"
                aws iam detach-role-policy --role-name "$role_name" --policy-arn "$policy_arn"
            done
            inline_policies=$(aws iam list-role-policies --role-name "$role_name" --query 'PolicyNames' --output text)
            for policy_name in $inline_policies; do
                echo "Deleting inline policy $policy_name from $role_name"
                aws iam delete-role-policy --role-name "$role_name" --policy-name "$policy_name"
            done
            echo "Attempting to delete role: $role_name"
            if aws iam delete-role --role-name "$role_name"; then
                echo "Successfully deleted role: $role_name"
            else
                echo "Failed to delete role: $role_name. Check for any remaining dependencies."
            fi
        else
            echo "Invalid resource ARN: $resource_arn"
        fi
    done
}

# Deletes an EKS cluster and its associated node groups
#
# This function deletes an Amazon EKS cluster and all of its associated node groups.
# The name of the EKS cluster to delete is provided as an input string to the function.
#
# Usage:
#   delete_eks_cluster_and_node_groups "cluster-name"
#   where "cluster-name" is the name of the EKS cluster you want to delete.
#
# Output:
#   Outputs the progress of deleting the node groups and the EKS cluster, including
#   waiting for each deletion to complete.
#
# Example(s):
#   delete_eks_cluster_and_node_groups "test-tt-test-wndq2t"
delete_eks_cluster_and_node_groups() {
    local CLUSTER_NAME=$1

    if [[ -z "$CLUSTER_NAME" ]]; then
        echo "No cluster name provided. Usage: delete_eks_cluster_and_node_groups <cluster-name>"
        return 1
    fi

    # Get the list of node groups associated with the cluster
    local NODE_GROUPS
    NODE_GROUPS=$(aws eks list-nodegroups --cluster-name "$CLUSTER_NAME" --query 'nodegroups[*]' --output text)

    # Delete each node group
    for NODE_GROUP in $NODE_GROUPS; do
        echo "Deleting node group $NODE_GROUP from cluster $CLUSTER_NAME..."
        aws eks delete-nodegroup --cluster-name "$CLUSTER_NAME" --nodegroup-name "$NODE_GROUP"
        echo "Waiting for node group $NODE_GROUP to be deleted..."
        aws eks wait nodegroup-deleted --cluster-name "$CLUSTER_NAME" --nodegroup-name "$NODE_GROUP"
    done

    # Delete the EKS cluster
    echo "Deleting EKS cluster $CLUSTER_NAME..."
    aws eks delete-cluster --name "$CLUSTER_NAME"
    echo "Waiting for EKS cluster $CLUSTER_NAME to be deleted..."
    aws eks wait cluster-deleted --name "$CLUSTER_NAME"

    echo "EKS cluster $CLUSTER_NAME and its node groups have been successfully deleted."
}

# Deletes KMS keys with a specific string in their alias
#
# This function searches for AWS KMS keys with a specific string in their alias name
# and deletes them. The search string is provided as an input to the function.
# The function lists aliases containing the search string, retrieves the associated key IDs,
# schedules the keys for deletion, and deletes the aliases.
#
# Usage:
#   delete_kms_keys_with_string "search-string"
#   where "search-string" is the string you want to search for in the KMS alias names.
#
# Output:
#   Outputs the progress of deleting each KMS key and its associated alias, including
#   scheduling the deletion of keys and deleting the aliases.
#
# Example(s):
#   Search for and delete KMS keys with "tt-test" in their alias:
#   delete_kms_keys_with_string "tt-test"
#
#   Delete all KMS keys with an empty string in their alias:
#   delete_kms_keys_with_string ' '
delete_kms_keys_with_string() {
    local search_string=$1

    if [[ -z "$search_string" ]]; then
        echo "No search string provided. Usage: delete_kms_keys_with_string <string>"
        return 1
    fi

    # Get a list of KMS aliases with the search string in the name
    local ALIAS_LIST
    if [[ "$search_string" == " " ]]; then
        # Only select aliases that are exactly a single space
        ALIAS_LIST=$(aws kms list-aliases --region "$AWS_DEFAULT_REGION" \
            --query "Aliases[?AliasName==' '].AliasName" --output text)
    else
        ALIAS_LIST=$(aws kms list-aliases --region "$AWS_DEFAULT_REGION" \
            --query "Aliases[?contains(AliasName, \`$search_string\`)].AliasName" --output text)
    fi

    # Process each alias in parallel
    echo "$ALIAS_LIST" | tr '\t' '\n' | while IFS= read -r ALIAS; do
        {
            if [[ -n "$ALIAS" ]]; then
                echo "Processing alias: $ALIAS"

                # Get the key ID associated with the alias
                KEY_ID=$(aws kms list-aliases --region "$AWS_DEFAULT_REGION" \
                    --query "Aliases[?AliasName=='$ALIAS'].TargetKeyId" --output text)

                if [[ -n "$KEY_ID" ]]; then
                    echo "Deleting key with alias: $ALIAS and key ID: $KEY_ID"

                    # Schedule key deletion (keys are not deleted immediately but scheduled for deletion)
                    aws kms schedule-key-deletion --key-id "$KEY_ID" --pending-window-in-days 7 --region "$AWS_DEFAULT_REGION"

                    echo "Scheduled deletion for key ID: $KEY_ID"

                    # Delete the alias
                    aws kms delete-alias --alias-name "$ALIAS" --region "$AWS_DEFAULT_REGION"

                    echo "Deleted alias: $ALIAS"
                else
                    echo "No key associated with alias: $ALIAS"
                fi
            fi
        } &
    done

    # Wait for all background processes to complete
    wait
}
