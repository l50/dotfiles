# Process Terminator
# Terminates a process given its name (case-insensitive)
#
# Usage:
#   process_terminator [process_name]
#
# Output:
#   No output, but terminates the specified process.
#
# Example(s):
#   process_terminator "myprocess"
process_terminator () {
  if pgrep -i "$1" > /dev/null
  then
    pkill -i $1
    echo "Process $1 has been terminated."
  else
    echo "No processes found with the name: $1"
  fi
}

# Extract
# An abstraction to get content from various compressed files.
#
# Usage:
#   extract [file]
#
# Output:
#   Extracts the content of the specified compressed file.
#
# Example(s):
#   extract archive.tar.gz
extract() {
	if [ -f $1 ]; then
		case $1 in
		*.tar.bz2) tar xvjf $1 ;;
		*.tar.gz) tar xvzf $1 ;;
		*.bz2) bunzip2 $1 ;;
		*.rar) rar x $1 ;;
		*.gz) gunzip $1 ;;
		*.tar) tar xvf $1 ;;
		*.tbz2) tar xvjf $1 ;;
		*.tgz) tar xvzf $1 ;;
		*.zip) unzip $1 ;;
		*.Z) uncompress $1 ;;
		*.7z) 7z x $1 ;;
		*) echo "don't know how to extract '$1'..." ;;
		esac
	else
		echo "'$1' is not a valid file!"
	fi
}

# File Size (fs)
# Determines the size of a file or total size of a directory.
#
# Usage:
#   fs [file|directory]
#
# Output:
#   Prints the size of the specified file or total size of the specified directory.
#
# Example(s):
#   fs myfile.txt
#   fs mydirectory
fs() {
	if du -b /dev/null >/dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* *
	fi
}

# Repository Root (repo_root)
# Changes the current directory to the root of the current Git repository.
#
# Usage:
#   repo_root
#
# Output:
#   Changes the current directory to the root of the current Git repository. If
#   the current directory is not part of a Git repository, prints an error message.
#
# Example(s):
#   repo_root
repo_root() {
  local root
  root=$(git rev-parse --show-toplevel 2> /dev/null)
  if [[ ! -z "${root}" ]]; then
    cd "${root}" || exit 1
  else
    echo "Current directory is not part of a git repository."
  fi
}

# onlycomments() function extracts only the comments from the contents of the specified file or from stdin.
# It supports extracting single-line comments that start with // or #, as well as multi-line comments that start with /* and end with */.
# The extracted comments are then printed to stdout, with each comment on a separate line.
#
# Usage:
#   onlycomments [file_path]
#   echo 'code with // comments' | onlycomments
#
# Output:
#   Only the comments extracted from the file or stdin, with each comment on a separate line.
#
# Example(s):
#   onlycomments "file.go"
#   echo 'code with // comments' | onlycomments
onlycomments () {
    if [ $# -eq 0 ]
    then
        grep -E '(//.*|/\*.*\*/|#.*)$'
    else
        file_path="$1"
        grep -E '(//.*|/\*.*\*/|#.*)$' "$file_path"
    fi
}


# nocomment() function removes all comments from the contents of the specified file or from stdin.
# It supports removing single-line comments that start with // or #, as well
# as multi-line comments that start with /* and end with */. The modified
# contents are then printed to stdout.
#
# Usage:
#   nocomment [file_path]
#   echo 'code with // comments' | nocomment
#
# Output:
#   The contents of the file or stdin without comments.
#
# Example(s):
#   nocomment "file.go"
#   echo 'code with // comments' | nocomment
nocomment () {
    if [ $# -eq 0 ]
    then
        sed -e 's://.*$::g' -e 's/#.*$//g' -e 's:/\*.*\*/::g' -e '/^\s*$/d'
    else
        file_path="$1"
        sed -e 's://.*$::g' -e 's/#.*$//g' -e 's:/\*.*\*/::g' -e '/^\s*$/d' "$file_path"
    fi
}

# Get list of tmux sessions
tmux_sessions() {
	for s in $(tmux list-sessions -F '#{session_name}'); do
		echo -e "\ntmux session name: $s\n--------------------"
		for p in $(tmux list-panes -s -F '#{pane_pid}' -t "$s"); do
			pstree -p -a $p
		done
	done
}

# Run tmux source-file ~/.tmux.conf on all panes
source_tmux_conf() {
	session=$(tmux display-message -p "#S")

	for pane in $(tmux list-panes -s -F "#{pane_id}"); do
		tmux send-keys -t $session.$pane "tmux source-file ~/.tmux.conf" C-m
	done
}

# Monitor ICMP traffic - great for OOB testing.
icmpMonitor() {
	tcpdump -i "$1" 'icmp and icmp[icmptype]=icmp-echo'
}

# get a line from a particular file
# input line number and file
# example: get_line 200 output.txt
get_line() {
	sed "$1q;d" $2
}

# Check spelling of markdown files in the current directory
spell-check-md() {
	for file in *.md; do
		aspell check --mode=markdown --lang=en "${file}"
	done
}

alias randommacaddrwifi="sudo spoof-mac randomize wi-fi"
alias diff="colordiff"

# Used to clone a web site - takes a website as the parameter
alias cloneSite="wget --mirror --convert-links --adjust-extension --page-requisites --no-parent"

# Get Public IP and Geolocation data
alias publicIP="curl -s https://ipapi.co/$(curl -s ifconfig.me)/json | jq"

# If we are not on an OSX system
if [[ $(uname) != 'Darwin' ]]; then
	alias open="xdg-open"
	alias openPorts="netstat -ntlp | grep LISTEN"
	# Largest files in the current directory and below
	alias largestFilesAndFolders="du -Sh | sort -rh | head -5"
	alias totalDisk='fdisk -l | grep Disk'
	# Find alias with zsh
	if test "$(which zsh)"; then
		alias zshAliasLocation="PS4='+%x:%I>' zsh -i -x -c '' |& grep"
	fi
	alias l.='ls -d .* --color=auto'
fi

# Repo Sync
# Synchronizes files between two git repositories while excluding .git directory.
#
# Usage:
#   repo_sync [source_directory] [target_directory]
#
# Output:
#   No output, but copies files from source directory to target directory.
#
# Example(s):
#   repo_sync "/path/to/src/repo" "/path/to/dest/repo"
repo_sync () {
  # Check if both directories exist
  if [[ -d "$1" ]] && [[ -d "$2" ]]; then
    # Use rsync to copy files from the source to the target
    rsync -av --exclude='.git/' "$1/" "$2/"
    echo "Sync complete."
  else
    echo "One or both directories do not exist. Please check the paths and try again."
  fi
}

# Get JSON Keys
# Fetches all the keys from a JSON file using jq.
#
# Usage:
#   getJSONKeys [json_file]
#
# Output:
#   Prints all the keys present in the JSON file.
#
# Example(s):
#   getJSONKeys "/path/to/jsonfile.json"
getJSONKeys() {
    jq 'keys' "$1"
}

# Get JSON Values
# Fetches all the values of array objects from a JSON file using jq.
#
# Usage:
#   getJSONValues [json_file]
#
# Output:
#   Prints all the values present in the JSON array objects.
#
# Example(s):
#   getJSONValues "/path/to/jsonfile.json"
getJSONValues() {
    jq '.[] | values' "$1"
}

# Fetches and optionally installs a tool from Github.
# The function fetches a binary tool from a GitHub releases page, verifies
# its checksum if one is provided, and optionally installs it in a directory
# that's in the PATH. It supports tar.gz archives for Linux and zip files for
# MacOS.
#
# After the process, it cleans up the artifacts. If installation is chosen,
# it will print a success message. If not, it will print the binary's execution path.
#
# Usage:
#   fetchFromGithub [author] [repository_name] [install] [github_token]
#
# Output:
#   Downloads the tool, verifies checksum if provided. If 'install' is set to
#   'true', it will install the tool and print a success message. If 'install'
#   is not set or set to 'false', it will print the execution path for the binary.
#
# Example(s):
#   fetchFromGithub "cli" "cli" # Just fetches the Github CLI
#   fetchFromGithub "cli" "cli" "true" # Fetches and installs the Github CLI
#   fetchFromGithub "cli" "cli" "true" "$GITHUB_TOKEN"
fetchFromGithub() {
    AUTHOR="$1"
    REPO_NAME="$2"
    INSTALL="${3:-false}"
    GITHUB_TOKEN="${4:-}"
    os=$(uname | tr '[:upper:]' '[:lower:]')
    arch=$(uname -m)

    if [[ "$arch" == "x86_64" ]]; then arch="amd64"; fi
    if [[ "$arch" == "aarch64" ]]; then arch="arm64"; fi
    if [[ "$os" == "darwin" ]]; then os="darwin"; fi

    if [ -n "$GITHUB_TOKEN" ]; then
        all_urls=$(curl -H "Authorization: token $GITHUB_TOKEN" -s "https://api.github.com/repos/$AUTHOR/$REPO_NAME/releases/latest" | jq -r '.assets[].browser_download_url')
    else
        all_urls=$(curl -s "https://api.github.com/repos/$AUTHOR/$REPO_NAME/releases/latest" | jq -r '.assets[].browser_download_url')
    fi

    download_url=$(echo "$all_urls" | grep "${os}_${arch}" | grep '.tar.gz' | grep -v 'deb\|rpm\|msi')
    checksum_url=$(echo "$all_urls" | grep 'checksums')

    if [ -z "$download_url" ]; then
        echo "No download URL found for OS: $os, architecture: $arch"
        return 1 # Stop execution of the function here
    fi

    curl -sLO "$download_url"
    filename=$(basename "$download_url")

    if [ -n "$checksum_url" ]; then
        curl -sLO "$checksum_url"
        checksum_file=$(basename "$checksum_url")
        if [[ "$os" == "macOS" ]]; then
            shasum -a 256 -c <(grep "$filename" "$checksum_file")
        else
            sha256sum -c --ignore-missing <(grep "$filename" "$checksum_file")
        fi
    fi

    # Save the current directory
    initial_dir=$(pwd)

    # Create a temporary directory and change to that directory
    tempdir=$(mktemp -d -t "ci-$(date +%Y-%m-%d-%H-%M-%S)-XXXXXXXXXX")
    pushd $tempdir || exit 1

    tar -xzvf "$initial_dir/$filename"

    binary_path="${tempdir}/$REPO_NAME"

    if [ ! -f "$binary_path" ]; then
        echo "Desired binary $REPO_NAME not found"
        return 1 # Stop execution of the function here
    fi

    if [[ "$INSTALL" == "true" ]]; then
        install_path="$HOME/.local/bin"

        # Create install_path if it doesn't exist
        mkdir -p "$install_path"

        # Move the binary to the install_path
        mv "$binary_path" "$install_path"
        echo "Installation of $REPO_NAME release from GitHub is complete."
    else
        echo "$REPO_NAME release from GitHub has been downloaded. Execute the binary by using the following path: $binary_path"
    fi

   # Change back to the previous directory and remove the temporary directory
    popd || exit 1
    rm -rf "$initial_dir/$filename" "$initial_dir/$checksum_file" "$tempdir"
}

alias networkedComputers="arp -a |grep -oP '\d+\.\d+\.\d+\.\d+'"

# If gshuf and cowsay are installed, then evolve our vocab with cowsay
# https://www.quora.com/What-is-the-most-interesting-shell-script-you-have-ever-written
if hash cowsay 2>/dev/null && hash gshuf 2>/dev/null; then
	gshuf -n 1 $HOME/.dotfiles/files/gre | cowsay
fi

# Set alias for nmap if it's installed
# https://github.com/hriesco/dotfiles/blob/master/.aliases
if hash nmap 2>/dev/null; then
	alias nmap="nmap --reason --open --stats-every 3m --max-retries 1 --max-scan-delay 20 --defeat-rst-ratelimit"
fi

alias ipaddr="ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'"
